Date: 10-13-23

# Exam Review

**What is the time complexity of a Turing Machine?**
O(n)


The language can be infinite, such as a*.

But the string is finite.

**What is a CST?**
Concrete Syntax Tree
The parse tree.
What distinguishes it?
Its leaves are the tokens or the epsilon of the omitted items.

**The parse tree is generated by what phase?**
Syntactic analysis

What is the abstract syntax tree?
Retains only the most essential items. It does not probably have any tokens as leaves. 
The abstract syntax tree could fit on one slide, while the concrete syntax tree could barely fit on four slides.

What phase produces abstract?
Semantic analysis

**Does a Deterministic Finite Automaton have more, same, or less descriptive power than a NonDeterministic Finite Automaton?**  
The same.
You can convert an NFA to an equivalent DFA.
It accepts the same langauge.

**Is it possible for a finite automaton to accept an infinite length string?**
No.
It cannot consume all of the input.

**Can a finite automaton reject an infinite length string?**
If it's a string that is going to be rejected, somewhere in that string is an incorrect symbol. The position of that incorrect symbol is a finite distance. 
Therefore, in a finite amount of time, we will get there.

# Flex
Flex generates a C lexical analyzer.
It offers better performance than lex.
It was part of the original Unix distribution, which is not free open source software.
Flex is free open source software.

Eric Schmidt was co-author of lex, and later become the 82nd richest person in the world.

Flex is remarkably stable. It does not need to be released often because it does what it does well. You should be using the latest version.

## Format
Flex is amazingly stupid on how it parses, how it understands the input file. The format was created in 1975.

One significant issue is flex's processing of comments. It is safest to stick with C's /* */ comments.

## Input File Structure
Flex input file is divided into three sections:
1. Definitions
2. Rules
3. User Code

## Definitions Section
flex is regular expression syntax is from an earlier, simpler age.  
Flex instead support Defined Names.  

## Matching Patterns
Professor Example:
```
[0-9]+ {/*int lit*/}
[0-9]+\.[0-9]+ {/* real lit */}

123.456

The real lit being the point (.)

Flex has to look one character to see if there is going to be another regular expression match possible.

It saw the dot and saw that matches, but the first one is on hold, but the second match is not yet finished. It needs to look ahead, perhaps what follows is ABC and it would then return back to the first match for int lit. Because what follows the dot is 456, it is a real lit.

Even though the regular expression will have an accept state for 123, it can see the next character is accept to a regular expression, it continues forward. Only when it gets to the point "Sorry it no longer matches" it goes BACK to the longest possible match that has already occurred. We call that maximal munch.

```


Do NOT write regular expresions that will match the same number of characters. Do not ever depend on the order of the rules with one exception.
> The only exception is the Illegal Character rule. One dot, and it should always be the last rule in the rules section. That is the catch for a character that did not match any regular expression. A single dot is the last rule.

Dot means match any character except new line. Without the rule, flex will crash, stop and exit, as an abnormal exit. You should always catch by having a bitbucket at the very end.

## Writing Action Routines

yylang will tell you how many characters were matched.
> Do not change yytext

There are two cases.

Ignoring whitespace, comments, we just get them out of the flow.

tok_INT_LIT, you have to return an attribute for that.


Do both flex exercises before next class.